# Comprehensive Guide to Nenyr Classes

Nenyr classes are the cornerstone of the declarative styling paradigm in the Nenyr DSL, empowering developers to define and manage robust, reusable, and efficient styles for HTML elements in their applications. This guide offers a comprehensive exploration of Nenyr classes, delving into their structure, capabilities, and best practices. Whether you are new to Nenyr or looking to optimize your styling workflow, this guide will equip you with the knowledge to fully harness the power of Nenyr classes for streamlined and maintainable CSS management.

## Understanding Nenyr Classes

A Nenyr class serves as a container for constructing styles to be applied to specific HTML elements. Each Nenyr class represents a collection of CSS utility class names, which are dynamically generated and globally unique. Importantly, these utility classes are never repeated, ensuring maximum efficiency and avoiding redundant code. When a property-value pair is used within a Nenyr class, the corresponding CSS utility class is generated once and reused wherever needed.

### Case Sensitivity

It is critical to note that Nenyr is case-sensitive. All methods and keywords must adhere to Pascal Case, meaning they start with an uppercase letter and capitalize the first letter of each subsequent word. Failure to follow this convention will result in syntax errors during compilation.

### Structure of a Nenyr Class

A Nenyr class is defined using the `Declare` keyword, followed by the `Class("className")` method. If the class inherits from another class, the `Deriving("parentClassName")` method is appended before defining the class body. The body of the class is enclosed within opening and closing curly brackets `{}`. Inside this body, you can define methods to specify the styles for the class.

Example:

```javascript
// Defining a class
Declare Class("myClassName") {
    // Class methods and style definitions go here
}

// or

// Defining a class with inheritance
Declare Class("myClassName") Deriving("parentClassName") {
    // Class methods and style definitions go here
}
```

## Methods Available in Nenyr Classes

Nenyr classes provide an array of methods that allow developers to define styles comprehensively. These methods can target main styles, pseudo-selectors, and responsive design requirements.

### Core Methods

#### `Important`

This method allows you to set the `!important` flag for all utility classes generated by the Nenyr class. It accepts a boolean value and defaults to `false`. Use this sparingly to avoid style conflicts caused by excessive use of `!important` rules.

**Example:**

```javascript
Important(true);
```

#### `Stylesheet`

The `Stylesheet` method is the primary place for defining the main styles of a class. It receives an object containing property-value pairs that correspond to CSS properties.

**Example:**

```javascript
Stylesheet({
    backgroundColor: "blue",
    display: "block",
    padding: "10px",
});
```

#### `PanoramicViewer`

This method enables responsive design by allowing styles to adapt based on predefined breakpoints in the **Breakpoints** method in the **Central Context**. It accepts an object where keys are breakpoint identifiers, and values are objects containing Stylesheet or other Nenyr methods.

**Example:**

```javascript
PanoramicViewer({
    MyBreakpointIdentifier({
        Stylesheet({
            fontSize: "1.2em",
            color: "red"
        }),
        Hover({
            backgroundColor: "yellow"
        })
    })
});
```

### Pseudo-Selectors and Additional Methods

Nenyr provides an extensive set of methods that map directly to CSS pseudo-selectors. These methods allow you to style specific states or parts of an element, such as `Hover`, `Active`, `Before`, `After`, and more. Unlike CSS, these methods are written in Pascal Case and do not include special characters.

For instance:

-   **After**: Selects and styles the `::after` pseudo-element of an element.
-   **Before**: Selects and styles the `::before` pseudo-element of an element.
-   **FirstLine**: Styles the first line of text inside an element.
-   **FirstLetter**: Styles the first letter of text inside an element.
-   **Hover**: Applies styles when the user hovers over an element with the pointer.
-   **Active**: Styles an element that is currently being activated (e.g., clicked or tapped).
-   **Focus**: Styles an element that has received focus (e.g., via keyboard or click).
-   **FirstChild**: Selects and styles the first child of a parent element.
-   **LastChild**: Selects and styles the last child of a parent element.
-   **FirstOfType**: Styles the first element of a specific type within its parent.
-   **LastOfType**: Styles the last element of a specific type within its parent.
-   **OnlyChild**: Selects and styles an element if it is the only child of its parent.
-   **OnlyOfType**: Styles an element if it is the only one of its type within its parent.
-   **Target**: Applies styles to an element targeted by a URL fragment (e.g., #id).
-   **Visited**: Styles links that the user has already visited.
-   **Checked**: Styles checkboxes or radio buttons that are checked.
-   **Disabled**: Styles elements that are disabled (e.g., form fields).
-   **Enabled**: Styles elements that are enabled (e.g., form fields).
-   **ReadOnly**: Styles input fields or elements with the readonly attribute.
-   **ReadWrite**: Styles input fields or elements that are editable.
-   **PlaceholderShown**: Styles input fields when the placeholder text is visible.
-   **Valid**: Styles form elements with valid input according to validation rules.
-   **Invalid**: Styles form elements with invalid input according to validation rules.
-   **Required**: Styles form elements with the required attribute.
-   **Optional**: Styles form elements without the required attribute.
-   **Fullscreen**: Styles an element in full-screen mode.
-   **FocusWithin**: Styles an element when it or any of its descendants have focus.
-   **OutOfRange**: Styles input elements with a value outside the specified range.
-   **Root**: Styles the root element of the document (e.g., \<html\>).
-   **Empty**: Styles elements with no children, including text nodes.

**Example:**

```javascript
Hover({
    backgroundColor: "green",
    color: "white",
});
Before({
    content: "''",
    display: "block",
    height: "2px",
    background: "black",
});
```

### Example of a Complete Nenyr Class

Below is a detailed example of a complete Nenyr class showcasing various methods and their use:

```javascript
Declare Class("buttonPrimary") Deriving("baseButton") {
    Important(true);
    Stylesheet({
        backgroundColor: "${primaryColor}",
        color: "${textColor}",
        borderRadius: "8px",
        padding: "12px 16px",
        textAlign: "center"
    });
    Hover({
        backgroundColor: "${hoverColor}",
        boxShadow: "0px 4px 6px ${shadowColor}"
    });
    Before({
        content: "''",
        display: "block",
        height: "4px",
        background: "${accentColor}"
    });
    PanoramicViewer({
        Mobile({
            Stylesheet({
                padding: "10px 14px",
                fontSize: "0.9em"
            })
        }),
        Desktop({
            Stylesheet({
                padding: "14px 18px",
                fontSize: "1.1em"
            })
        })
    });
}
```

### Key Characteristics of Nenyr Classes

1. **Unique CSS Utility Classes**: Every property-value pair results in a unique utility class, which is never repeated.
2. **Inheritance**: Classes can inherit from other classes using the `Deriving` method, allowing for a hierarchical organization of styles.
3. **Pseudo-Selectors**: Supports a rich set of pseudo-selector methods for granular control of element states.
4. **Responsive Design**: The `PanoramicViewer` method ensures styles adapt seamlessly to different screen sizes and breakpoints.

## Best Practices

-   **Use `Important` Judiciously**: Overusing the `!important` flag can lead to difficulties in maintaining and debugging styles. Use it only when absolutely necessary.
-   **Keep Styles Modular**: Define small, reusable classes rather than monolithic ones to promote scalability and maintainability.
-   **Organize Breakpoints**: Define consistent and clear breakpoints in the central context to streamline responsive design.
-   **Test Extensively**: Ensure that classes work correctly in various scenarios and that utility classes are applied as intended.

## Conclusion

_It is also important to clarify that there is no CSS utility class being generated repeatedly. If you use a Nenyr property-value pair multiple times, only one CSS utility class will be generated for that specific property-value pair. Utilizing the same property-value pair inside a Nenyr class allows the Nenyr class to reference the existing CSS utility class without duplicating the CSS code itself. This ensures that Galadriel CSS knows that the styles corresponding to the CSS utility class should be applied to the elements represented by the Nenyr class, maintaining efficiency and consistency in the generated styles._

Nenyr classes provide a powerful, efficient, and scalable way to define and manage styles in your application. By adhering to the principles and practices outlined in this guide, you can leverage the full potential of Nenyr to create clean, maintainable, and performant styles. Whether you are building simple components or complex layouts, Nenyr's structured approach to class definitions and styling ensures a seamless and intuitive development experience.
