# Understanding Nenyr Markups in Galadriel CSS

**Galadriel CSS** integrates **Nenyr markups** and the **integration client** to offer a sophisticated, modular, and efficient approach to styling applications. This powerful combination empowers developers to manage and apply styles dynamically, both during **development mode** (using a local **Axum server**) and in **build mode** (where styles are pre-compiled into a **JSON file**). This document provides an in-depth explanation of how Nenyr markups work in **Galadriel CSS**, including practical examples and important considerations to follow for effective usage.

---

## 1. What Are Nenyr Markups?

**Nenyr markups** serve as the foundation for defining how and where styles are applied to HTML elements. These markups play a crucial role in linking your components to the styles generated by **Galadriel CSS**. They are part of a **declarative styling approach** where styles are referenced by classes within a specific context.

Nenyr markups enable clean separation of concerns, allowing developers to manage styles for the application more efficiently. They are particularly useful in complex applications, where context-based styling is required.

### Key Syntax Structure of Nenyr Markups

A Nenyr markup typically follows a well-defined structure to clearly indicate which styles should be applied, where they should be applied, and in which context they're localized. The basic elements of Nenyr markup include:

1. **Context Type**: Identifies the type of context for the style. This can be one of the following:

    - **Central Context**: Global styles across the application.
    - **Layout Context**: Styles related to the layout.
    - **Module Context**: More granular styles specific to individual modules or components.

2. **Context Name** (optional): When necessary, a specific name for the context is defined to allow for a more granular control over styles. For example, layout-related or module-related styles might require context names like `myLayoutContext` or `myModuleContext`.

3. **Nenyr Class Name**: The class within the context that is referenced by the markup.

#### Example of Nenyr Markups

Here are detailed examples of Nenyr markups for different contexts:

1. **Central Context** (Global Styles) use the context type **@class**, does not require a context name:

    ```html
    <div class="@-central:myCentralClassName"></div>

    <!-- The "-" is not part of the syntax, it is there only to Galadriel CSS don't try to inject styles there. This application is being styled with Galadriel CSS. -->
    ```

    - This markup refers to `myCentralClassName` in the **Central Context**. During the build process, this will be replaced with a utility class corresponding to the global style.

2. **Layout Context** (Layout-specific Styles) use the context type **@layout**, does require a context name:

    ```html
    <div class="@-layout:myLayoutContext::myLayoutClassName"></div>

    <!-- The "-" is not part of the syntax, it is there only to Galadriel CSS don't try to inject styles there. This application is being styled with Galadriel CSS. -->
    ```

    - This markup refers to `myLayoutClassName` in the `myLayoutContext`, which is a layout-specific context. The corresponding utility class will be injected during the build process.

3. **Module Context** (Component-specific Styles) use the context type **@module**, does require a context name:

    ```html
    <div class="@-module:myModuleContext::myModuleClassName"></div>

    <!-- The "-" is not part of the syntax, it is there only to Galadriel CSS don't try to inject styles there. This application is being styled with Galadriel CSS. -->
    ```

    - This markup refers to `myModuleClassName` within the `myModuleContext`, a context related to the specific module or component. The utility class will be injected during the build process.

These Nenyr markups will be dynamically transformed into corresponding utility classes during the build process or in real-time during development. Example:

```html
<div class="@-central:myCentralClassName"></div>
<div class="@-layout:myLayoutContext::myLayoutClassName"></div>
<div class="@-module:myModuleContext::myModuleClassName"></div>
```

##### The development code above is transformed into this code in the build output:

```html
<div class="utility-class-one utility-class-two utility-class-three"></div>
<div class="utility-class-one utility-class-two"></div>
<div class="utility-class-one"></div>
```

---

## 2. The Special \@galadrielcss styles\; Directive

The \@galadrielcss styles\; directive is a special feature that allows developers to apply **global styles** directly within the application's entry point CSS file. This directive will be replaced by global styles generated by **Galadriel CSS**, ensuring that overarching design rules are applied consistently throughout the application.

### Placement of \@galadrielcss styles\;

-   **Placement in Entry-Point CSS**: The \@galadrielcss styles\; directive must be placed at the top of your entry point CSS file or in a designated global CSS file. This ensures that global styles are processed first and are integrated into the final build.

    Example:

    ```css
    /* In your global CSS file (global.css) */
    @-galadrielcss styles;

    /* The "-" is not part of the syntax, it is there only to Galadriel CSS don't try to inject styles there. This application is being styled with Galadriel CSS. */
    ```

-   **Functionality**: This directive will be replaced by all global styles from **Galadriel CSS**. These styles will then be applied globally across your application, guaranteeing design consistency without redundancy.

---

## 3. The Integration Client: Handling Nenyr Markups

The **integration client** plays a crucial role in processing **Nenyr markups** and ensuring the appropriate utility class names are applied to your components. It functions in two modes: **Development Mode** and **Build Mode**.

### Development Mode

In **Development Mode**, the integration client operates in real-time and communicates with a local **Axum server**. This allows dynamic resolution and injection of **Nenyr classes** as you develop your application.

#### Process in Development Mode:

1. **Markup Identification**: The integration client scans the application code for **Nenyr markups**.
2. **Requesting Data from Axum Server**: The client sends requests to the local **Axum server**, which responds with the corresponding utility class names for the markups or the generated CSS rules for the directive.
3. **Dynamic Style Injection**: The integration client replaces the **Nenyr markups** in the application code with the appropriate **utility class names** or replaces the directive by the **CSS rules**, ensuring that the correct styles are applied in real-time.

### Build Mode

In **Build Mode**, the integration client no longer relies on a server. Instead, it reads a **JSON file** that contains the **final CSS** and **Nenyr class tracking map**. This ensures that the styles are applied correctly even when the application is compiled for production.

#### Process in Build Mode:

1. **JSON File Generation**: During the build process, **Galadriel CSS** compiles the styles and generates a **JSON file** containing the mapping of **Nenyr classes** to their corresponding **utility class names** and the compiled **CSS rules**.
2. **Integration Client Reads JSON**: The integration client uses the JSON file to replace **Nenyr markups** or **Nenyr directive** with the correct utility classes or global styles.
3. **Class Injection**: The final output includes the proper utility class names and CSS rules, ensuring a correctly styled application when deployed.

---

## 4. The \@galadrielcss styles\; Directive and Nenyr Markups

One important rule in **Galadriel CSS** is that **each application should have only one \@galadrielcss styles\; directive**. This directive defines the **global styles** for the entire application.

On the other hand, you can have **multiple Nenyr markups** for different components, allowing each component to be styled according to its specific context (Central, Layout, or Module).

**Key Rule**: _Only Nenyr classes can be applied to components_. All other styles must be created in **Nenyr documents** and applied to classes to affect HTML elements.

#### Why This is Important:

-   This approach ensures that styles are kept modular, organized, and scalable.
-   By maintaining a single \@galadrielcss styles\; directive for global styles and using multiple Nenyr markups for components, you avoid redundancy and ensure consistency across the entire application.
-   It ensures that **only one Nenyr document** governs the global styles, keeping everything consistent and easy to manage.

#### Example:

```html
<!-- Correct usage with multiple Nenyr markups -->
<div class="@-layout:grid::myGridLayout @-module:button::primaryButton"></div>

<!-- The "-" is not part of the syntax, it is there only to Galadriel CSS don't try to inject styles there. This application is being styled with Galadriel CSS. -->
```

```jsx
const className = "@-layout:grid::myGridLayout @-module:button::primaryButton";

<div className={className}></div>
<div className="@-layout:grid::myGridLayout @-module:button::primaryButton"></div>

// The "-" is not part of the syntax, it is there only to Galadriel CSS don't try to inject styles there. This application is being styled with Galadriel CSS.
```

In this example, there are **Nenyr markups** for different contexts (`layout` and `module`) being applied together. These markups are transformed into the appropriate **utility class names** during the build process. Example in the final build output:

```html
<div class="utility-class-one utility-class-two utility-class-three"></div>
```

```jsx
const className = "utility-class-one utility-class-two utility-class-three";

<div className={className}></div>
<div className="utility-class-one utility-class-two"></div>
```

---

## Conclusion

In **Galadriel CSS**, the combination of **Nenyr markups** and the **integration client** creates a highly efficient and modular system for styling web applications.

-   **Nenyr markups** define how styles are applied to HTML elements, and the **integration client** ensures that these styles are resolved and injected appropriately.
-   During **development mode**, real-time style resolution occurs through interaction with a local **Axum server**.
-   In **build mode**, the final styles are generated into a **JSON file**, which the integration client uses to inject the necessary utility classes into the application.

##### Observation:

_After all injections are completed, the integration client removes the JSON file generated by Galadriel CSS, which contains the data used for injecting styles and utility class names. The final build output includes only the injected CSS rules and the utility class names applied directly to the HTML elements. This ensures that the production-ready output is entirely static and fully optimized, with no residual references to Galadriel CSS or its processes. The result is a lightweight, efficient build that consists solely of the necessary CSS and HTML, guaranteeing a clean and performant application without any trace of the framework's runtime components or intermediate artifacts._

By adhering to the guidelines of using a single **\@galadrielcss styles\; directive** for global styles and leveraging **multiple Nenyr markups** for specific component styles, developers can maintain a clean, efficient, and scalable approach to styling their applications.
